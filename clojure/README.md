## Clojure - шпаргалка

Тут я постараюсь вести краткие записи о фичах Clojure, которые использую в решениях задач AoC.

### 02

`reduce conj [] ()` - `reduce` применяет функцию из первого параметра (`conj`), параметрами которой являются второй параметр `reduce` и первый элемент последовательности. Затем берётся результат выполнения функции и передается первым параметром в заново вызываемую функцию, а вторым -- второй элемент последовательности, и т.д. Таким образом `reduce` проходит функцией по всем элементам последовательности, используя результат функции на прошлой итерации для модификации первого параметра функции на текущем. Иными словами, _Редьюс обходит коллекцию применяя лямбду к паре элементов, то что вернёт лямбда на первой паре станет первым значением при следующем вызове лямбды, а вторым - следующий элемент из коллекции._ В данном случае `conj` будет один за другим присоединять элементы последовательности к пустому вектору, переданному первым параметром.

### 03

`(def input_vals (mapv #(str/split % #"") (str/split-lines (slurp "../input/input03.txt"))))` -- считывает данные из файла построчно, и разбивает строки посимвольно в вектор векторов. `slurp` считывает все содержимое файла в строку. `str/split-lines` разбивает строку на подстроки по \n и возвращает вектор подстрок (строк файла). `mapv` применяет функцию, переданную в первом параметре, к каждому элементу вектора и возвращает вектор. Применяемая функция `(str/split % #"")` разбивает строки по разделителю - решулярному выражению, в данном случае отделяется каждый символ.

`(def turned_vals (apply mapv list input_vals))` -- "поворачивает" матрицу входных значений так, что первая строка становится первым столбцом и наоборот.

`(let [] ...)` - в Clojure специальная форма, позволяющая определять переменные, доступные внутри данного блока. Позволяет в некоторых случаях обходить иммутабельность переменных в языке.

Литерал функции `#_()` позволяет выполнить только одно выражении, в отличии от лямбда-функций `(fn [])`. Для выполнения нескольких выражений, нужно группировать их через `let`, `do` и т.п.

`(keep-indexed (fn [i v] (if (= "1" v) i)) ["1" "1" "0" "0" "1"])` - лямбда-функция внутри принимает два аргумента, первый из которых -- текущий индекс, второй -- элемент коллекции по этому индексу. С каждым проходом индекс увеличивается. `if` внутри вернет индекс того элемента, который совпадает со строкой `"1"` в условии.

`(key (apply max-key val {"1" 7, "0" 3})` - выдает ключ мапа, значение по которому максимально из всех значений. `apply` применяет функцию и данные ей аргументы к последовательности, переданной последним аргументом. `max-key` принимает функцию и значение из последовательности, и возвращает то значение, для которого фунцкия(значение) максимально. В данном случае функция `val` принимает ключ мапа как аргумент, и выдает значение по этому ключу. Внешняя функция `key` наоборот, возвращает ключ данного значения.
